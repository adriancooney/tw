#!/usr/bin/env babel-node --
import moment from "moment";
import handlebars from "handlebars";
import Promise from "bluebird";
import Teamwork from "../src/Teamwork";
import * as cli from "../src/cli";
import { CLIError } from "../src/cli/error";
import Command from "../src/library/Command";
import { Debug } from "../src/library/Debug";
import { Log } from "../src/model";

const debug = Debug("tw:cmd:log");

export default class LogCommand extends Command {
    setup(command) {
        command
            .description("Log time to a project, tasklist or task.")
            .option("-d, --duration <duration>", "Specify the duration of the log.")
            .option("-F, --fill", "Log the time since your last log today.")
            .option("-m, --message <message>", "Specify the log message.")

        // Add the scoep selector options -tsp, -TSP
        // Example: "Log the time to a project"
        this.addScopeOptions(command, "Log the time to");

        command
            .option("-y, --no-prompt", "Don't prompt to confirm the log.")
            .option("--time <time>", "Set the start time of the log")
            .option("--date <date>", "Set the date of the log.")
            .option("--timestamp <timestamp>", "Set the start timestamp (Unix).");
    }

    execute(options) {
        return this.getAPI().then((api) => {
            return [api, this.requireScopeFromOptions(api, options)];
        }).spread((api, item) => {
            if(options.fill && options.duration)
                throw new CLIError(`Please specify either a duration ${this.color.option("-d")} or ${this.color.option("--fill")}, not both.`);

            if(options.fill) {
                if(options.date || options.time)
                    throw new CLIError(`Cannot use ${this.color.option("--time")} or ${this.color.option("--date")} with ${this.color.option("--fill")}.`);

                // The user asks us to fill the time since the last
                // time entry. It only does it for the current project
                // and if it's within the last day so we don't go
                // filling in weeks
                var currentProject = this.getCurrent("project"),
                    currentUser = this.getCurrent("user");

                return api.getLogs(currentProject, { 
                    user: currentUser, 
                    // TODO: Allow custom start of day to be input
                    // Get logs since today at 8:00AM
                    from: moment().startOf("day").subtract(4, "hour"),
                    to: moment()
                }).then(logs => {
                    // Get the lastest time
                    var [timestamp, log] = logs.reduce(([lastTimestamp, lastLog], currentLog) => {
                        // Get the log start date and add it's duration
                        var currentTimestamp = moment(currentLog.date).add(currentLog.duration);

                        // If this is the first (or only), just return it
                        if(!lastTimestamp) return [currentTimestamp, currentLog];

                        // If it's after the lastest timestamp, it is now the new latest
                        if(currentTimestamp.isAfter(lastTimestamp)) return [currentTimestamp, currentLog];
                        else return [lastTimestamp, lastLog];
                    }, []);

                    // If we have no log today, cop out!
                    if(!log) 
                        throw new CLIError(`No recent time logs today. You can only ${this.color.option("--fill")} since your last time log today.`);

                    var diff = moment().diff(timestamp, "m");

                    // Check to make sure we actually have a time and it's greater than at *least* five minutes
                    if(diff < 5) 
                        throw new CLIError(`Your last log was ${timestamp.fromNow()}. It must be at least 5 minutes since your last log. Come on now, don't be silly.`);

                    const offset = timestamp, duration = moment.duration(diff, "m");

                    return [api, item, duration, offset];
                });
            } else {
                // We have out task/project, now let's parse out duration.
                let duration = options.duration;

                if(!duration) 
                    throw new CLIError(`Please specify the duration ${this.color.option("-d")} of the log or use the ${this.color.option("--fill")} option.`);

                // Parse the duration. This will fail if it's invaild.
                duration = Teamwork.parse("duration", duration);

                // Create the moment object
                duration = moment.duration(duration);

                // And the offset. Defaults to now - duration
                let offset = moment().subtract(duration);

                // Set a specific start time for the log
                if(options.date) {
                    if(!options.time)
                        throw new CLIError(`When using ${this.color.option("--date")}, you must specify a ${this.color.option("--time")}.`);

                    // Date and time
                    offset = moment(options.date + " " + options.time, "DD:MM:YYYY HH:mm"); // TODO: Allow for configuration of date format
                } else if(options.time) {
                    // Set a time from today
                    offset = moment(options.time, "HH:mm");
                }

                return [api, item, duration, offset];
            }
        }).spread((api, item, duration, offset) => {
            var message;

            // Get the message for the timelog via -m switch
            if(options.message) message = options.message;
            else {
                // Default to prompt for a message with $EDITOR. Returns a promise!
                message = cli.input.promptWithEditor(`Logging ${duration.humanize()} to ${item.toString()}.\n${item.getURL()}`);
            }

            return [api, item, duration, offset, message];
        }).spread((api, item, duration, offset, message) => {
            if(!message.trim().length)
                throw new CLIError("Empty message. Aborting.", undefined, false);

            // Update any template variables in the message
            message = handlebars.compile(message)({ duration: duration.humanize() });

            if(options.prompt) {
                let confirmation = `You are about to log ${this.color.duration(duration.humanize())} to ${this.color.cyan(item.toString())}`;
                if(options.time) confirmation += ` (starting ${offset.calendar()})`
                confirmation += ".\nDo you wish to continue?"

                const cancellation = `Log aborted.`

                // Confirm the log they're about to make
                return cli.input.proceed(confirmation, cancellation).then((proceed) => {
                    return [api, item, duration, offset, message];
                });
            } else return [api, item, duration, offset, message];
        }).spread((api, item, duration, offset, message) => {
            // Actually log the time with the API
            // Take a minute to realize the beauty that is the Moment API.
            return api.log(item, Log.create(moment.duration(duration), offset, this.getCurrent("user"), message.trim()));
        }).then((log) => {
            cli.output.done(log.toString());
        });
    }
}

if(require.main === module)
    cli.run(LogCommand);