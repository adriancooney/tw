#!/usr/bin/env babel-node
import Command from "../src/library/Command";
import * as cli from "../src/cli";
import { CLIError } from "../src/cli/error";

const TASK_WIDTH                = 105;
const INDEX_NOTATION            = " {{i}}. ";
const CHILD_MIDDLE_NOTATION     = " ├──";
const CHILD_END_NOTATION        = " └──";
const CHILD_OVERFLOW_NOTATION   = " |  ";
const CHILD_WIDTH               = TASK_WIDTH - CHILD_MIDDLE_NOTATION.length;

export default class TasksCommand extends Command {
    setup(command) {
        command
            .option("-f, --filter <string>", "Filter the tasks by title containing <string>.")
            .option("--completed", "Display completed tasks.");

        this.addScopeOptions(command, "List tasks for", ["tasklist"]);
    }

    execute(options) {
        return this.getAPI().then(api => {
            return [api, this.requireScopeFromOptions(api, options, ["tasklist"])];
        }).spread((api, scope) => {
            return [scope, api.getTasks(scope, {
                completed: options.completed
            })];
        }).spread((scope, tasks) => {
            cli.output.log(cli.output.scope(scope));

            this.listTasks(tasks, {
                filter: options.filter ? this.createFilter(options.filter) : undefined
            });
        });
    }

    createFilter(filter) {
        try {
            return RegExp(filter, "gi");
        } catch(e) {
            throw new CLIError(`Invalid filter "${filter}".`);
        }
    }

    shouldShowTask(task, filter) {
        if(task.title.match(filter)) return true;
        if(task.subTasks) return task.subTasks.some(task => this.shouldShowTask(task, filter));
    }

    listTasks(tasks, { filter, level = 0, recursive = true } = {}) {
        if(filter)
            tasks = tasks.filter(task => this.shouldShowTask(task, filter));

        tasks.forEach((task, i, tasks) => {
            const index = `[${task.completed ? "X" : " "}] `;

            let taskTitle = this.color.task(task.title);

            // Add the meta information
            taskTitle += ` (#${task.id}, ${task.progress}%)`;

            if(task.description) {
                taskTitle += `\n${cli.format.indent(task.description, cli.format.whitespace(2))}\n`;
            }

            // Resize the task title to fit TASK_WIDTH in columns
            taskTitle = cli.format.resize(taskTitle, process.stdout.columns - 6 - index.length);

            // Indent the block of text so that it's inline with the index
            taskTitle = cli.format.alignIndent(index, taskTitle, level === 0 ? " |" : undefined);

            if(level > 0) {
                const isLastTask = i === tasks.length - 1;
                const indentation = isLastTask ? CHILD_END_NOTATION : CHILD_MIDDLE_NOTATION;
                taskTitle = cli.format.alignIndent(indentation, taskTitle, !isLastTask ? CHILD_OVERFLOW_NOTATION : undefined)

                if(level > 1)
                    taskTitle = cli.format.indent(taskTitle, cli.format.whitespace(indentation.length));
            }

            // Highlight the filter if any
            if(filter)
                taskTitle = taskTitle.replace(filter, match => cli.output.highlight(match));

            cli.output.log(taskTitle);

            if(recursive && task.subTasks)
                this.listTasks(task.subTasks, { filter, recursive, level: level + 1 });
        });
    }

    logTasksOld(scope, tasks) {
        // Flatten the task list
        tasks = tasks.reduce((list, task) => {
            list.push({ task, level: 0 });

            if(task.subTasks) {
                list = list.concat(task.subTasks.map((t) => { return { task: t, level: 1}; }));
            }

            return list;
        }, []);

        if(options.filter) {
            const filter = this.createFilter(options.filter);

            // Filter the tasks 
            tasks = tasks.filter(({ task }) => task.title.match(filter));
        }


        tasks.forEach(({ task, level }, i, tasks) => {
            let index = INDEX_NOTATION.replace("{{i}}", i + 1);

            // Resize the task title to fit TASK_WIDTH in columns
            let taskTitle = cli.format.resize(task.title, level > 0 ? CHILD_WIDTH : TASK_WIDTH);

            // Indent the block of text so that it's inline with the index
            taskTitle = cli.format.indent(taskTitle, cli.format.whitespace(index.length));
            taskTitle = index + taskTitle.substr(index.length);

            // Grab the indent. This decides whether its a corner pipe or T pipe characters
            if(i < (tasks.length - 1) && tasks[i + 1].level > 0) {
                // We have a task with a task above and below it
                taskTitle = CHILD_MIDDLE_NOTATION +
                    cli.format.indent(taskTitle, CHILD_OVERFLOW).substr(CHILD_MIDDLE_NOTATION.length);
            } else if(level > 0) {
                // We have a task with just one task above it (none below)
                taskTitle = CHILD_END_NOTATION + 
                    cli.format.indent(taskTitle, cli.format.whitespace(CHILD_END_NOTATION.length)).substr(CHILD_END_NOTATION.length);
            }

            cli.output.log(taskTitle);
        });
    }
}

if(require.main === module)
    cli.run(TasksCommand);