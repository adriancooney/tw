#!/usr/bin/env babel-node
import Command from "../src/library/Command";
import * as cli from "../src/cli";
import { CLIError } from "../src/cli/error";

const TASK_WIDTH                = 105;
const INDEX_NOTATION            = " {{i}}. ";
const CHILD_MIDDLE_NOTATION     = " ├── ";
const CHILD_END_NOTATION        = " └── ";
const CHILD_OVERFLOW_NOTATION   = " |  ";
const CHILD_WIDTH               = TASK_WIDTH - CHILD_MIDDLE_NOTATION.length;

export default class TasksCommand extends Command {
    setup(command) {
        command
            .option("-f, --filter <string>", "Filter the tasks by title containing <string>.")
            .option("--completed", "Display completed tasks.");

        this.addScopeOptions(command, "List tasks for", ["tasklist"]);
    }

    execute(options) {
        return this.getAPI().then(api => {
            return [api, this.requireScopeFromOptions(api, options, ["tasklist"])];
        }).spread((api, scope) => {
            return [scope, api.getTasks(scope, {
                completed: options.completed
            })];
        }).spread((scope, tasks) => {
            cli.output.log(cli.output.scope(scope));

            this.listTasks(tasks, {
                filter: options.filter ? this.createFilter(options.filter) : undefined,
                completed: options.completed,
                user: this.getCurrent("user")
            });
        });
    }

    /**
     * Create a filter from a string or throw an error if it fails.
     * @param  {String} filter 
     * @return {RegExp}
     */
    createFilter(filter) {
        try {
            return RegExp(filter, "gi");
        } catch(e) {
            throw new CLIError(`Invalid filter "${filter}".`);
        }
    }

    /**
     * Determine whether we should display a task given a filter. This traverses
     * children to see if the filter matches, if it finds a matching child, it
     * returns true.
     * @param  {Task}   task   
     * @param  {RegExp} filter 
     * @return {Boolean}
     */
    shouldShowTask(task, filter) {
        if(task.title.match(filter)) return true;
        if(task.subTasks) return task.subTasks.some(task => this.shouldShowTask(task, filter));
    }

    getTaskMeta(task) {
        // The meta information
        let meta = [task.progress + "%"];

        // Add assignee if any
        if(task.assigned) meta.push(task.assigned.getNameInitialed());

        return " (" + meta.join(", ") + ")";
    }

    /**
     * List the tasks.
     * @param  {Array} tasks             
     * @param  {RegExp} options.filter    
     * @param  {Boolean} options.completed Show whether task was completed or not.
     * @param  {Number} options.level     The current indentation level of this list.
     * @param  {Boolean} options.recursive List subtasks if there is any.
     */
    listTasks(tasks, { user, filter, completed, level = 0, recursive = true } = {}) {
        if(filter)
            tasks = tasks.filter(task => this.shouldShowTask(task, filter));

        tasks.forEach((task, i, tasks) => {
            let indentation = completed ? `[${task.completed ? cli.output.TICK : " "}] ` : "";

            if(level > 0) {
                // Add the pipes
                const isLastTask = i === tasks.length - 1;
                const indentNotation = isLastTask ? CHILD_END_NOTATION : CHILD_MIDDLE_NOTATION;

                indentation = indentNotation + indentation;

                if(level > 1)
                    indentation = cli.format.whitespace(indentNotation.length) + indentation;
            }

            // Add the task ID to the start
            indentation = `#${task.id} ` + indentation;

            let taskTitle = task.title;
            let meta = this.getTaskMeta(task);

            // Highlight the filter in the title if any passed
            if(filter) taskTitle = taskTitle.replace(filter, match => cli.output.highlight(match));

            // Colorize and cut the task title to (window size - meta)
            taskTitle = cli.format.ellipsize(taskTitle, process.stdout.columns - meta.length - indentation.length - 6);

            // Stylize the task
            // TODO: Highlight overdue tasks in red
            if(task.assigned && task.assigned.id === user.id) taskTitle = this.color.bold(this.color.magenta(taskTitle));
            else if(task.completed) taskTitle = this.color.green(taskTitle);
            else taskTitle = this.color.yellow(taskTitle);

            cli.output.log(indentation + taskTitle + meta);

            // Log the sub tasks if there is any
            if(recursive && task.subTasks) {
                this.listTasks(task.subTasks, { user, filter, completed, recursive, level: level + 1 });
            }
        });
    }
}

if(require.main === module)
    cli.run(TasksCommand);